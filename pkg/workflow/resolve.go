package workflow

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"

	"github.com/github/gh-aw/pkg/console"
	"github.com/github/gh-aw/pkg/constants"
	"github.com/github/gh-aw/pkg/logger"
	"github.com/github/gh-aw/pkg/stringutil"
	"github.com/goccy/go-yaml"
)

var resolveLog = logger.New("workflow:resolve")

// ResolveWorkflowName converts an agentic workflow ID to the GitHub Actions workflow name.
// It normalizes the input by removing .md and .lock.yml extensions, then finds the
// corresponding workflow files and extracts the actual workflow name from the lock.yml file.
//
// The agentic workflow ID is the basename of the markdown file without the .md extension.
// The GitHub Actions workflow name is extracted from the "name:" field in the corresponding .lock.yml file.
//
// Examples:
//   - "weekly-research" -> "Weekly Research" (from weekly-research.lock.yml name field)
//   - "weekly-research.md" -> "Weekly Research" (from weekly-research.lock.yml name field)
//   - "weekly-research.lock.yml" -> "Weekly Research" (from weekly-research.lock.yml name field)
func ResolveWorkflowName(workflowInput string) (string, error) {
	if workflowInput == "" {
		return "", nil
	}

	resolveLog.Printf("Resolving workflow name for input: %s", workflowInput)

	// Normalize the workflow name by removing extensions
	normalizedName := stringutil.NormalizeWorkflowName(workflowInput)
	resolveLog.Printf("Normalized workflow name: %s", normalizedName)

	// Get the workflows directory
	workflowsDir := constants.GetWorkflowDir()

	// Check if the agentic workflow markdown file exists
	mdFile := filepath.Join(workflowsDir, normalizedName+".md")
	if _, err := os.Stat(mdFile); err != nil {
		resolveLog.Printf("Markdown file not found: %s", mdFile)
		suggestions := []string{
			fmt.Sprintf("Run '%s status' to see all available workflows", constants.CLIExtensionPrefix),
			fmt.Sprintf("Create a new workflow with '%s new %s'", constants.CLIExtensionPrefix, normalizedName),
			"Check for typos in the workflow name",
		}
		return "", errors.New(console.FormatErrorWithSuggestions(
			fmt.Sprintf("agentic workflow '%s' not found (expected file: %s)", normalizedName, mdFile),
			suggestions,
		))
	}

	// The corresponding lock file name is what GitHub Actions uses as the workflow name
	lockFileName := normalizedName + ".lock.yml"
	lockFile := filepath.Join(workflowsDir, lockFileName)

	// Check if the lock file exists (should be generated by compile)
	if _, err := os.Stat(lockFile); err != nil {
		suggestions := []string{
			fmt.Sprintf("Run '%s compile' to compile the workflow", constants.CLIExtensionPrefix),
			fmt.Sprintf("Run '%s compile %s' to compile this specific workflow", constants.CLIExtensionPrefix, normalizedName),
		}
		return "", errors.New(console.FormatErrorWithSuggestions(
			fmt.Sprintf("compiled workflow '%s' not found (expected file: %s)", normalizedName, lockFile),
			suggestions,
		))
	}

	// Read and parse the lock file to extract the workflow name
	content, err := os.ReadFile(lockFile)
	if err != nil {
		return "", fmt.Errorf("failed to read lock file '%s': %w", lockFile, err)
	}

	// Parse YAML to extract the name field
	var workflow struct {
		Name string `yaml:"name"`
	}

	if err := yaml.Unmarshal(content, &workflow); err != nil {
		return "", fmt.Errorf("failed to parse YAML from lock file '%s': %w", lockFile, err)
	}

	if workflow.Name == "" {
		resolveLog.Printf("Workflow name field missing in lock file: %s", lockFile)
		suggestions := []string{
			fmt.Sprintf("Run '%s compile %s' to recompile the workflow", constants.CLIExtensionPrefix, normalizedName),
			"Check if the workflow file has a valid 'name' field in the frontmatter",
		}
		return "", errors.New(console.FormatErrorWithSuggestions(
			fmt.Sprintf("workflow name not found in lock file '%s'", lockFile),
			suggestions,
		))
	}

	resolveLog.Printf("Successfully resolved workflow name: %s", workflow.Name)
	return workflow.Name, nil
}
